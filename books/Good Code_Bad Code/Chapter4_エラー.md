### 回復可能なエラー
- ネットワークエラー
- 深刻でないタスクエラー
    
### 回復不可能なエラー
- コードと一緒にあるべきリソースがない
- 他のコードを誤用している(無効な入力で関数を呼び出している、必須な初期化がされていない)
    
### 早い失敗と目立つ失敗
- 早い失敗とは、問題が起きた場所の近くでエラーを通知すること = エラーの原因が明確になる
- 目立つ失敗とは、わかりやすくエラーを吐かせること = 敢えてクラッシュさせることはエラーを見逃すことを防ぐが、堅牢性を損なう
- 堅牢性を損なわないために、例外をキャッチする、エラーの状態をロギングする、エラーの頻度をモニタリングする(頻度の閾値を超えれば警告が届く)がある
    
### エラーを隠さない(アンチパターン)
- エラーが起きた場合にデフォルト値を返すのは、エラーが埋もれる機会になる
- エラーが起きた場合にnullを返す、同上
- 何もしない
=> エラーは通知した方がいい

### エラーを通知するための様々なテクニックと、選ぶための考慮
#### 明示的: 検査例外
エラーをスローしたことをエンジニアが認識できる ≒ コンパイル時にエラーとなり発見される？
1. 検査例外をスローする
2. 検査例外をキャッチする

Javaは検査例外の概念があるが、こういった概念がない言語がある(その場合、例外処理はすべて非検査例外)

#### 暗黙的: 非検査例外
エラーをスローするが、コードは動く。ドキュメントに情報を記載することを推奨
エンジニアがエラーをスローしたことを気づかない可能性がある

#### 明示的: null許容型の戻り値
null安全がサポートされている場合、null許容型を戻り値の型として利用することで、明示的にエラーを通知する. 
サポートしていない場合、オプショナル型を使用するといい.  
- 戻り値をnullにすることでエラーの原因が不明瞭になる
	=>コメントやドキュメントで説明する必要がある
1. 例外の場合、nullを返すようにする
2. nullを処理する(nullかどうかを検査して、処理をする)

#### 明示的: Result型の戻り値
Result型を戻り値として利用する = エラーの理由が明らか

#### 明示的: エラーを示す戻り値
true/falseで戻り値を返す。
エラーの状態が3つ以上あるときは列挙型（Enum）が役に立ちます。


<details>
  <summary>JS, TSの列挙型</summary>
  **JavaScript** では、伝統的な意味での「列挙型（Enum）」は存在しません。ただし、JavaScriptのオブジェクトを使用してEnumのような動作をエミュレートすることが可能です。
  例えば、以下のように色を表すEnumを作成することができます：

	```js
	`const Color = {   RED: 'RED',   BLUE: 'BLUE',   GREEN: 'GREEN' };  console.log(Color.RED);  // Outputs: 'RED'`
	```
	
このようにして定義した`Color`オブジェクトは、読み取り専用のプロパティを持つEnumとして機能します。
	
一方で、**TypeScript** では明確な列挙型（Enum）がサポートされています。TypeScriptのEnumは、具体的な名前と値の組み合わせを持つ特別な型です。以下に例を示します：
	
	```ts	
	`enum Color {   Red = 'RED',   Blue = 'BLUE',   Green = 'GREEN' }  let myColor: Color = Color.Red;  console.log(myColor);  // Outputs: 'RED'`
	```
	
このように、TypeScriptのEnumは名前付きの定数を効率的に管理するための方法を提供しています。  
</details>

- 問題点: 値が返されていても容易に無視でき、またエラーを示す戻り値があることに気づかない可能性がある

#### 暗黙的: Promise型 Future型
#### 暗黙的: マジックバリューを返す
正常な戻り値と同じ型を持つ特定の値に特別な意味を持たせる.  
例) 負の値(エラーを発生させる値）が引数として渡された場合、必ず-1.0という値を返す.   
=> 良くない。。？

### 回復不可能なエラーを通知する
- 非検査例外をスローする
- サポートされている言語なら、panicを起こす
- 検査やアサーションを使う

