## Chapter2 抽象化レイヤー
### 問題を綺麗な抽象化レイヤーで小さな問題に切り分ける方法
抽象化レイヤーの作成 = 大きな問題を再起的に小さな問題に分割すること  
=>個々のコード自体を単純化し、コード全体の複雑さを制御できる。

### 抽象化レイヤーがコードの品質を保つためにどう役立つか
- 読みやすさ
- モジュール性
- 再利用性と汎用化
- テスタビリティ

### コードのレイヤー
コードの単位は他のコードの単位に依存する
- 関数
- クラス
- インターフェース
- パッケージ、名前空間、モジュール

### APIと実装の詳細
- コードの呼び出し元から見えるもの(公開されているクラス、インターフェイス、関数、その概念や入力値など)
- コードの呼び出し元から見えないもの　　
APIの側面からコードを考えることは、綺麗な抽象化レイヤーを考えることに役立つ。APIは呼び出し元に公開される概念を定義し、それ以外は実装の詳細だからです。


### コードを明確な抽象化レイヤーに分割する方法
#### **関数**
- ひとつの関数は単一のタスクを行う
- 他の適切な名前をつけた関数を呼び出し、より複雑な振る舞いを構成する　　

#### **クラス**
- 1つのクラスは1つのことに関心を持つべき
- 1つのクラスは凝集すべき
  
**凝集**: クラス内のモノがどれだけ適切なクラスに「所属」しているかどうか。高い方が良い。　　
機能を実行するために関連するものを纏められた方がいいよねって感じ。　　
- 逐次的凝集 
　1つの出力が他の入力に必要な場合、逐次的凝集が発生する。
- 機能的凝集 (最善)
　一連のものが全て1つのタスクのために働く場合、機能的凝集が発生する。
    
**関心の分離**: システムが個別に対処している関心ごとに、独立したコンポーネントとして分離すべき、と推奨する設計原則。   

適切なサイズのクラスは下記を達成する
- コードを読みやすくする
- コードをモジュール化する (機能の一部をモジュールとして交換する)
- コードの再利用性を高め、汎用化しやすくする
- テストしやすいコードを書き、適切にテストする

### インターフェイス
レイヤー間の境界を明確にしたり、実装の詳細がそれぞれのレイヤー間で漏れ出していないことを担保するために利用するアプローチとしてインターフェースを定義することがある。  

メリット
- パブリックAPIを明確にする
- 想定外の実装追加に対応できる
- テストしやすくなる
- 同じクラスで2つの小さな問題を解決できる  
デメリット  
- 少し手間
- コードをより複雑化する

コードが複雑になるパターンが多いため、メリットが多い場合のみ使用する方がよい  

### コードが薄すぎる時
レイヤー分割で発生するコストや負荷  
- クラスを定義したり依存関係を新しくファイルに取り入れたりするために、ボイラープレートコードが必要になるため、より多くのコードが発生する. 
- 一連のロジックを巡るためにファイルやクラスを切り替える労力がいる. 

不要なレイヤー分割は上記のデメリットに重みがまし、かえって不便ということです。バランス大事。ただ、薄いより厚い方が問題として大きく悪いため、迷ったら薄い方向の記述に寄せた方がいい。  

### マイクロサービスとは何か
マイクロサービスアーキテクチャは、個々の問題の解決策を1つのプログラムにコンパイルしたライブラリーでなく、独立したサービスとしてデプロイします。  
つまり、システムをそれぞれ設定されたタスク専用の小さなプログラムに分割するということです。それぞれは、リモートAPIを通じて呼ぶことができる専用のサービスとしてデプロイされます。  
バックエンドとフロントエンドをほぼ完全に分割することも可能
